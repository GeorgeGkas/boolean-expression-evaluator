{"version":3,"sources":["ArgsBuilder.tsx","BinaryExpressionTree.ts","OperationBuilder.tsx","BinaryExpressionTreeProvider.tsx","PostfixEvaluator.tsx","App.tsx","renameArgsKeysInPlace.ts","index.tsx"],"names":["ArgsBuilder","props","onArgsChange","Object","entries","args","map","idx","argName","argValue","type","value","onChange","e","target","trim","old","name","new","defaultValue","String","onClick","keys","length","Operation","BinaryExpressionTree","rootId","nodePool","Map","root","this","createGenericNode","id","set","Array","from","values","nodeId","get","parentId","parent","node","GENERIC","level","ARGUMENT","createArgumentBinaryExpressionTreeNode","CONSTANT","createConstantBinaryExpressionTreeNode","CONJUNCTION","createConjunctionBinaryExpressionTreeNode","DISJUNCTION","createDisjunctionBinaryExpressionTreeNode","add","nodeIdToRemove","thisNode","parentNode","size","delete","traversalDFS","childNodesToRemove","changeNodeTypeById","newNodeType","newNodeValue","allowComplexToSimplex","Error","genericNode1","genericNode2","Set","uuid","constantValue","thisNodeId","rootNodeId","visitedNodeIds","stack","push","pop","has","childNodesId","lastVisitedChild","nodeChildrenId","reverse","childId","dereferencedChildren","dereferenceChildren","GenericOptions","ConstantOptions","DisjunctionOptions","ConjunctionOptions","ArgsOptions","BuildOperationOptions","normalizeNodeValue","OperationBuilder","removeNode","binaryExpressionTree","removeNodeById","updateBinaryExpressionTreeNodes","addOperation","addChildNode","React","useEffect","binaryExpressionTreeNodes","changeNodeValueById","shift","className","normalizedNodeValue","style","marginLeft","normalizedType","normalizedValue","targetValue","startsWith","split","BinaryExpressionTreeContext","createContext","BinaryExpressionTreeProvider","Provider","children","PostfixEvaluator","operationResult","binaryExpressionTreeNodesPostOrder","result","reduce","prev","curr","evaluateOperation","App","useState","setArgs","useContext","getRootId","setBinaryExpressionTreeNodes","traversalPostOrder","setBinaryExpressionTreeNodesPostOrder","changedArgs","obj","newKeys","keyValues","key","assign","renameArgsKeysInPlace","rootElement","document","getElementById","render"],"mappings":"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","file":"static/js/main.e11ee385.chunk.js","sourcesContent":["import React from 'react'\nimport type { IArgsChange } from './App'\n\nexport type Args = { [argname: string]: boolean }\n\nconst ArgEntry =\n  (onArgsChange: (changedArgs: IArgsChange) => void) =>\n  ([argName, argValue]: [string, boolean], idx: number): JSX.Element => {\n    const onArgValueChange = (e: React.ChangeEvent<HTMLSelectElement>) =>\n      onArgsChange({\n        old: {\n          name: argName,\n          value: argValue,\n        },\n        new: {\n          name: argName,\n          value: e.target.value === 'true',\n        },\n      })\n\n    const onArgNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      if (!e.target.value.trim()) {\n        // Do not allow empty arg names.\n        return\n      }\n\n      onArgsChange({\n        old: {\n          name: argName,\n          value: argValue,\n        },\n        new: {\n          name: e.target.value.trim(),\n          value: argValue,\n        },\n      })\n    }\n\n    return (\n      <section key={idx}>\n        <input type=\"name\" value={argName} onChange={onArgNameChange} />\n        <select onChange={onArgValueChange} defaultValue={String(argValue)}>\n          <option value=\"true\">true</option>\n          <option value=\"false\">false</option>\n        </select>\n      </section>\n    )\n  }\n\nexport default function ArgsBuilder(props: {\n  args: Args\n  onArgsChange: (changedArgs: IArgsChange) => void\n}): JSX.Element {\n  const createNewArg = () =>\n    props.onArgsChange({\n      old: {},\n      new: {\n        name: `newArg${Object.keys(props.args).length}`,\n        value: false,\n      },\n    })\n\n  return (\n    <form>\n      {Object.entries(props.args).map(ArgEntry(props.onArgsChange))}\n\n      <button type=\"button\" onClick={createNewArg}>\n        + add arg\n      </button>\n    </form>\n  )\n}\n","import { v4 as uuid } from 'uuid'\n\nexport const enum Operation {\n  GENERIC = 'GENERIC',\n  DISJUNCTION = 'Disjunction',\n  CONJUNCTION = 'Conjunction',\n  ARGUMENT = 'Argument',\n  CONSTANT = 'Constant',\n}\n\nexport type BinaryExpressionTreeNodeIdType = string\nexport type BinaryExpressionTreeNodeParentType =\n  BinaryExpressionTreeNodeIdType | null\nexport type BinaryExpressionTreeNodeType<T> =\n  | IGenericBinaryExpressionTreeNode\n  | IArgumentBinaryExpressionTreeNode\n  | IConstantBinaryExpressionTreeNode\n  | IConjunctionBinaryExpressionTreeNode<T>\n  | IDisjunctionBinaryExpressionTreeNode<T>\nexport type BinaryExpressionTreeNodeTypeArray = Array<\n  | IGenericBinaryExpressionTreeNode\n  | IArgumentBinaryExpressionTreeNode\n  | IConstantBinaryExpressionTreeNode\n  | IConjunctionBinaryExpressionTreeNode<BinaryExpressionTreeNodeTypeArray>\n  | IDisjunctionBinaryExpressionTreeNode<BinaryExpressionTreeNodeTypeArray>\n>\n\nexport interface IGenericBinaryExpressionTreeNode {\n  id: BinaryExpressionTreeNodeIdType\n  type: Operation.GENERIC\n  value: 'select...'\n  parent: BinaryExpressionTreeNodeParentType\n  level: number\n}\n\nexport interface IArgumentBinaryExpressionTreeNode {\n  id: BinaryExpressionTreeNodeIdType\n  type: Operation.ARGUMENT\n  value: string\n  parent: BinaryExpressionTreeNodeParentType\n  level: number\n}\n\nexport interface IConstantBinaryExpressionTreeNode {\n  id: BinaryExpressionTreeNodeIdType\n  type: Operation.CONSTANT\n  value: boolean\n  parent: BinaryExpressionTreeNodeParentType\n  level: number\n}\n\nexport interface IConjunctionBinaryExpressionTreeNode<T> {\n  id: BinaryExpressionTreeNodeIdType\n  type: Operation.CONJUNCTION\n  value: T\n  parent: BinaryExpressionTreeNodeParentType\n  level: number\n}\n\nexport interface IDisjunctionBinaryExpressionTreeNode<T> {\n  id: BinaryExpressionTreeNodeIdType\n  type: Operation.DISJUNCTION\n  value: T\n  parent: BinaryExpressionTreeNodeParentType\n  level: number\n}\n\nexport class BinaryExpressionTree {\n  private rootId: BinaryExpressionTreeNodeIdType\n  private nodePool: Map<\n    BinaryExpressionTreeNodeIdType,\n    BinaryExpressionTreeNodeType<Set<BinaryExpressionTreeNodeIdType>>\n  > = new Map()\n\n  constructor() {\n    const root = this.createGenericNode(null, 0)\n    this.rootId = root.id\n    this.nodePool.set(root.id, root)\n  }\n\n  getRootId() {\n    return this.rootId\n  }\n\n  getNodes() {\n    return Array.from(this.nodePool.values())\n  }\n\n  getNodeFromId(nodeId: BinaryExpressionTreeNodeIdType) {\n    return this.nodePool.get(nodeId)\n  }\n\n  addChildNode<T>(\n    type: Operation,\n    parentId: BinaryExpressionTreeNodeIdType,\n    value?: T\n  ): BinaryExpressionTreeNodeIdType {\n    const parent = this.nodePool.get(parentId)!\n\n    const node = {\n      [Operation.GENERIC]: () =>\n        this.createGenericNode(parentId, parent.level + 1),\n      [Operation.ARGUMENT]: () =>\n        this.createArgumentBinaryExpressionTreeNode(\n          parentId,\n          value as unknown as string,\n          parent.level + 1\n        ),\n      [Operation.CONSTANT]: () =>\n        this.createConstantBinaryExpressionTreeNode(\n          parentId,\n          value as unknown as boolean,\n          parent.level + 1\n        ),\n      [Operation.CONJUNCTION]: () =>\n        this.createConjunctionBinaryExpressionTreeNode(\n          parentId,\n          parent.level + 1\n        ),\n      [Operation.DISJUNCTION]: () =>\n        this.createDisjunctionBinaryExpressionTreeNode(\n          parentId,\n          parent.level + 1\n        ),\n    }[type]()\n\n    ;(parent.value as Set<BinaryExpressionTreeNodeIdType>).add(node.id)\n    this.nodePool.set(node.id, node)\n\n    return node.id\n  }\n\n  removeNodeById(nodeIdToRemove: BinaryExpressionTreeNodeIdType) {\n    const thisNode = this.nodePool.get(nodeIdToRemove)!\n\n    if (thisNode.type === Operation.GENERIC) {\n      if (thisNode.id === this.rootId) {\n        return\n      }\n\n      const parentNode = this.nodePool.get(thisNode.parent!)!\n\n      if (\n        parentNode.type === Operation.CONJUNCTION ||\n        parentNode.type === Operation.DISJUNCTION\n      ) {\n        if (\n          (parentNode.value as Set<BinaryExpressionTreeNodeIdType>).size < 3\n        ) {\n          return\n        }\n      }\n\n      ;(parentNode!.value as Set<BinaryExpressionTreeNodeIdType>).delete(\n        thisNode.id\n      )\n      this.nodePool.delete(thisNode.id)\n\n      return\n    }\n\n    for (const childNodesToRemove of this.traversalDFS(nodeIdToRemove)) {\n      if (childNodesToRemove.id === nodeIdToRemove) {\n        this.changeNodeTypeById(\n          nodeIdToRemove,\n          Operation.GENERIC,\n          'select...',\n          true\n        )\n        continue\n      }\n\n      this.nodePool.delete(childNodesToRemove.id)\n    }\n  }\n\n  changeNodeTypeById(\n    nodeId: BinaryExpressionTreeNodeIdType,\n    newNodeType: Operation,\n    newNodeValue?: string | boolean,\n    allowComplexToSimplex = false\n  ) {\n    const node = this.nodePool.get(nodeId)!\n\n    if (\n      !allowComplexToSimplex &&\n      (node.type === Operation.CONJUNCTION ||\n        node.type === Operation.DISJUNCTION) &&\n      newNodeType !== Operation.CONJUNCTION &&\n      newNodeType !== Operation.DISJUNCTION\n    ) {\n      throw new Error('is not possible to change complex operation to simple')\n    }\n\n    if (\n      (newNodeType === Operation.CONJUNCTION ||\n        newNodeType === Operation.DISJUNCTION) &&\n      node.type !== Operation.CONJUNCTION &&\n      node.type !== Operation.DISJUNCTION\n    ) {\n      const genericNode1 = this.createGenericNode(node.id, node.level + 1)\n      const genericNode2 = this.createGenericNode(node.id, node.level + 1)\n\n      this.nodePool.set(genericNode1.id, genericNode1)\n      this.nodePool.set(genericNode2.id, genericNode2)\n\n      node.value = new Set([genericNode1.id, genericNode2.id]) as any\n      node.type = newNodeType as any\n      return\n    }\n\n    node.type = newNodeType\n    node.value = newNodeValue ?? node.value\n  }\n\n  changeNodeValueById(\n    nodeId: BinaryExpressionTreeNodeIdType,\n    value: string | boolean | Set<BinaryExpressionTreeNodeIdType>\n  ) {\n    const node = this.nodePool.get(nodeId)!\n\n    node.value = value\n  }\n\n  createGenericNode(\n    parent: BinaryExpressionTreeNodeParentType,\n    level: number\n  ): IGenericBinaryExpressionTreeNode {\n    return {\n      id: uuid(),\n      type: Operation.GENERIC,\n      value: 'select...',\n      parent,\n      level,\n    }\n  }\n\n  createArgumentBinaryExpressionTreeNode(\n    parent: BinaryExpressionTreeNodeParentType,\n    argValue: string,\n    level: number\n  ): IArgumentBinaryExpressionTreeNode {\n    const thisNodeId = uuid()\n\n    return {\n      id: thisNodeId,\n      type: Operation.ARGUMENT,\n      value: argValue,\n      parent,\n      level,\n    }\n  }\n\n  createConstantBinaryExpressionTreeNode(\n    parent: BinaryExpressionTreeNodeParentType,\n    constantValue: boolean,\n    level: number\n  ): IConstantBinaryExpressionTreeNode {\n    const thisNodeId = uuid()\n\n    return {\n      id: thisNodeId,\n      type: Operation.CONSTANT,\n      value: constantValue,\n      parent,\n      level,\n    }\n  }\n\n  createDisjunctionBinaryExpressionTreeNode(\n    parent: BinaryExpressionTreeNodeParentType,\n    level: number\n  ): IDisjunctionBinaryExpressionTreeNode<Set<BinaryExpressionTreeNodeIdType>> {\n    const thisNodeId = uuid()\n\n    const genericNode1 = this.createGenericNode(thisNodeId, level + 1)\n    const genericNode2 = this.createGenericNode(thisNodeId, level + 1)\n\n    this.nodePool.set(genericNode1.id, genericNode1)\n    this.nodePool.set(genericNode2.id, genericNode2)\n\n    return {\n      id: thisNodeId,\n      type: Operation.DISJUNCTION,\n      value: new Set([genericNode1.id, genericNode2.id]),\n      parent,\n      level,\n    }\n  }\n\n  createConjunctionBinaryExpressionTreeNode(\n    parent: BinaryExpressionTreeNodeParentType,\n    level: number\n  ): IConjunctionBinaryExpressionTreeNode<Set<BinaryExpressionTreeNodeIdType>> {\n    const thisNodeId = uuid()\n\n    const genericNode1 = this.createGenericNode(thisNodeId, level + 1)\n    const genericNode2 = this.createGenericNode(thisNodeId, level + 1)\n\n    this.nodePool.set(genericNode1.id, genericNode1)\n    this.nodePool.set(genericNode2.id, genericNode2)\n\n    return {\n      id: thisNodeId,\n      type: Operation.CONJUNCTION,\n      value: new Set([genericNode1.id, genericNode2.id]),\n      parent,\n      level,\n    }\n  }\n\n  *traversalDFS(rootNodeId: BinaryExpressionTreeNodeIdType) {\n    const visitedNodeIds: Set<BinaryExpressionTreeNodeIdType> = new Set()\n    const stack: BinaryExpressionTreeNodeIdType[] = []\n\n    stack.push(rootNodeId)\n\n    while (stack.length) {\n      const nodeId = stack.pop()!\n      if (!visitedNodeIds.has(nodeId)) {\n        const node = this.nodePool.get(nodeId)!\n        if (\n          node.type === Operation.CONJUNCTION ||\n          node.type === Operation.DISJUNCTION\n        ) {\n          for (const childNodesId of node.value) {\n            stack.push(childNodesId)\n          }\n        }\n\n        yield node\n      }\n    }\n  }\n\n  *traversalPostOrder(rootNodeId: BinaryExpressionTreeNodeIdType) {\n    const stack: BinaryExpressionTreeNodeIdType[] = []\n    let lastVisitedChild: BinaryExpressionTreeNodeIdType | null = null\n\n    stack.push(rootNodeId)\n\n    while (stack.length) {\n      const nodeId = stack[stack.length - 1]\n      const node = this.nodePool.get(nodeId)!\n\n      if (\n        (node.type !== Operation.CONJUNCTION &&\n          node.type !== Operation.DISJUNCTION) ||\n        !node.value.size ||\n        (lastVisitedChild && node.value.has(lastVisitedChild))\n      ) {\n        yield node\n        stack.pop()\n        lastVisitedChild = node.id\n      } else {\n        const nodeChildrenId = [...node.value].reverse()\n        for (const childId of nodeChildrenId) {\n          stack.push(childId)\n        }\n      }\n    }\n  }\n\n  dereferenceChildren(nodeId: BinaryExpressionTreeNodeIdType) {\n    const node = this.nodePool.get(nodeId)!\n\n    if (\n      node.type === Operation.CONJUNCTION ||\n      node.type === Operation.DISJUNCTION\n    ) {\n      const dereferencedChildren: BinaryExpressionTreeNodeTypeArray = []\n      for (const childId of node.value) {\n        dereferencedChildren.push(this.dereferenceChildren(childId))\n      }\n      node.value = dereferencedChildren as any\n    }\n\n    return node as BinaryExpressionTreeNodeType<BinaryExpressionTreeNodeTypeArray>\n  }\n\n  toJSON(): BinaryExpressionTreeNodeType<BinaryExpressionTreeNodeTypeArray> {\n    return this.dereferenceChildren(this.rootId)\n  }\n}\n","import React from 'react'\nimport { Args } from './ArgsBuilder'\nimport {\n  BinaryExpressionTree,\n  BinaryExpressionTreeNodeIdType,\n  BinaryExpressionTreeNodeType,\n  Operation,\n} from './BinaryExpressionTree'\n\nimport './OperationBuilder.css'\n\nconst GenericOptions = (props: { args: Args }) => (\n  <>\n    <option value={Operation.GENERIC}>select...</option>\n    <option value={Operation.CONSTANT}>constant</option>\n    {Object.keys(props.args).length && (\n      <option value={Operation.ARGUMENT}>argument</option>\n    )}\n    <option value={Operation.CONJUNCTION}>and</option>\n    <option value={Operation.DISJUNCTION}>or</option>\n  </>\n)\nconst ConstantOptions = () => (\n  <>\n    <option value={`${Operation.CONSTANT}-true`}>true</option>\n    <option value={`${Operation.CONSTANT}-false`}>false</option>\n  </>\n)\n\nconst DisjunctionOptions = () => (\n  <>\n    <option value={Operation.CONJUNCTION}>and</option>\n    <option value={Operation.DISJUNCTION}>or</option>\n  </>\n)\n\nconst ConjunctionOptions = DisjunctionOptions\n\nconst ArgsOptions = (props: { args: Args }) => {\n  return (\n    <>\n      {Object.entries(props.args).map(([argName], id) => (\n        <option key={id} value={`${Operation.ARGUMENT}-${argName}`}>\n          {argName}\n        </option>\n      ))}\n    </>\n  )\n}\n\nconst BuildOperationOptions = (props: {\n  type: Operation\n  args: Args\n}): JSX.Element => {\n  return {\n    [Operation.GENERIC]: <GenericOptions args={props.args} />,\n    [Operation.CONSTANT]: <ConstantOptions />,\n    [Operation.ARGUMENT]: <ArgsOptions args={props.args} />,\n    [Operation.CONJUNCTION]: <ConjunctionOptions />,\n    [Operation.DISJUNCTION]: <DisjunctionOptions />,\n  }[props.type]\n}\n\nconst normalizeNodeValue = (\n  type: Operation,\n  value: string | boolean | Set<BinaryExpressionTreeNodeIdType>,\n  args: Args\n) => {\n  if (typeof value === 'object') {\n    if (type === Operation.CONJUNCTION) {\n      return Operation.CONJUNCTION\n    } else {\n      return Operation.DISJUNCTION\n    }\n  } else if (typeof value === 'string') {\n    return `${Operation.ARGUMENT}-${value}`\n  } else {\n    return `${Operation.CONSTANT}-${value}`\n  }\n}\n\nexport function OperationBuilder(props: {\n  args: Args\n  binaryExpressionTreeNodes: BinaryExpressionTreeNodeType<\n    Set<BinaryExpressionTreeNodeIdType>\n  >[]\n  binaryExpressionTree: BinaryExpressionTree\n  updateBinaryExpressionTreeNodes: () => any\n}): JSX.Element {\n  const isNodeTypeConjunctionOrDisjunction = (type: Operation) =>\n    type === Operation.CONJUNCTION || type === Operation.DISJUNCTION\n  const changeNodeType =\n    (nodeId: BinaryExpressionTreeNodeIdType) =>\n    (e: React.ChangeEvent<HTMLSelectElement>) => {\n      const targetValue = e.target.value\n\n      let normalizedType: Operation\n      let normalizedValue: string | undefined | boolean\n\n      if (targetValue.startsWith(Operation.DISJUNCTION)) {\n        normalizedType = Operation.DISJUNCTION\n      } else if (targetValue.startsWith(Operation.CONJUNCTION)) {\n        normalizedType = Operation.CONJUNCTION\n      } else if (targetValue.startsWith(Operation.ARGUMENT)) {\n        normalizedType = Operation.ARGUMENT\n        normalizedValue = targetValue.split('-').pop()!\n      } else if (targetValue.startsWith(Operation.CONSTANT)) {\n        normalizedType = Operation.CONSTANT\n        normalizedValue = targetValue.split('-').pop() === 'true'\n      } else {\n        // targetValue.startsWith(Operation.GENERIC)\n        normalizedType = Operation.GENERIC\n      }\n\n      props.binaryExpressionTree.changeNodeTypeById(\n        nodeId,\n        normalizedType,\n        normalizedValue\n      )\n\n      props.updateBinaryExpressionTreeNodes()\n    }\n\n  const removeNode = (nodeId: BinaryExpressionTreeNodeIdType) => () => {\n    props.binaryExpressionTree.removeNodeById(nodeId)\n    props.updateBinaryExpressionTreeNodes()\n  }\n\n  const addOperation = (nodeId: BinaryExpressionTreeNodeIdType) => () => {\n    props.binaryExpressionTree.addChildNode(Operation.GENERIC, nodeId)\n    props.updateBinaryExpressionTreeNodes()\n  }\n\n  React.useEffect(() => {\n    for (const node of props.binaryExpressionTreeNodes) {\n      if (\n        normalizeNodeValue(node.type, node.value, props.args) ===\n        'Argument-Argument'\n      ) {\n        props.binaryExpressionTree.changeNodeValueById(\n          node.id,\n          Object.keys(props.args).shift()!\n        )\n        props.updateBinaryExpressionTreeNodes()\n        return\n      }\n    }\n  }, [props])\n\n  return (\n    <div className=\"operation-builder-wrapper\">\n      {props.binaryExpressionTreeNodes.map((node, idx) => {\n        const normalizedNodeValue = normalizeNodeValue(\n          node.type,\n          node.value,\n          props.args\n        )\n        return (\n          <section\n            className=\"operation-node\"\n            key={idx}\n            style={{\n              marginLeft: `${node.level * 30}px`,\n            }}>\n            <div>\n              <select\n                value={normalizedNodeValue}\n                onChange={changeNodeType(node.id)}>\n                <BuildOperationOptions type={node.type} args={props.args} />\n              </select>\n              <button\n                className=\"operation-node-remove-button\"\n                onClick={removeNode(node.id)}>\n                âœ–\n              </button>\n            </div>\n            <div>\n              <button\n                className={`operation-node-add-op-button ${\n                  !isNodeTypeConjunctionOrDisjunction(node.type) ? 'hidden' : ''\n                }`}\n                onClick={addOperation(node.id)}>\n                + add op\n              </button>\n            </div>\n          </section>\n        )\n      })}\n    </div>\n  )\n}\n","import React from 'react'\nimport { BinaryExpressionTree } from './BinaryExpressionTree'\n\nconst BinaryExpressionTreeContext = React.createContext<BinaryExpressionTree>(\n  new BinaryExpressionTree()\n)\n\nconst BinaryExpressionTreeProvider = (props: React.PropsWithChildren<any>) => (\n  <BinaryExpressionTreeContext.Provider value={new BinaryExpressionTree()}>\n    {props.children}\n  </BinaryExpressionTreeContext.Provider>\n)\n\nconst useBinaryExpressionTree = () =>\n  React.useContext<BinaryExpressionTree>(BinaryExpressionTreeContext)\n\nexport { BinaryExpressionTreeProvider as default, useBinaryExpressionTree }\n","import { Args } from './ArgsBuilder'\nimport {\n  BinaryExpressionTreeNodeType,\n  BinaryExpressionTreeNodeIdType,\n  Operation,\n} from './BinaryExpressionTree'\n\nconst evaluateOperation = (\n  binaryExpressionTreeNodesPostOrder: BinaryExpressionTreeNodeType<\n    Set<BinaryExpressionTreeNodeIdType>\n  >[],\n  args: Args\n) => {\n  let stack: boolean[] = []\n\n  for (const node of binaryExpressionTreeNodesPostOrder) {\n    if (node.type === Operation.GENERIC) {\n      return undefined\n    } else if (node.type === Operation.ARGUMENT) {\n      stack.push(args[node.value])\n    } else if (node.type === Operation.CONSTANT) {\n      stack.push(node.value)\n    } else if (node.type === Operation.CONJUNCTION) {\n      const result = stack.reduce((prev, curr) => prev && curr, stack.shift()!)\n      stack = []\n      stack.push(result)\n    } else {\n      // node.type === Operation.DISJUNCTION\n      const result = stack.reduce((prev, curr) => prev || curr, stack.shift()!)\n      stack = []\n      stack.push(result)\n    }\n  }\n\n  return stack.pop()!\n}\n\nexport function PostfixEvaluator(props: {\n  args: Args\n  binaryExpressionTreeNodesPostOrder: BinaryExpressionTreeNodeType<\n    Set<BinaryExpressionTreeNodeIdType>\n  >[]\n}): JSX.Element {\n  const operationResult = String(\n    evaluateOperation(props.binaryExpressionTreeNodesPostOrder, props.args)\n  )\n\n  return <p>{operationResult}</p>\n}\n","import React from 'react'\nimport ArgsBuilder from './ArgsBuilder'\nimport type { Args } from './ArgsBuilder'\nimport { renameArgsKeysInPlace } from './renameArgsKeysInPlace'\nimport { OperationBuilder } from './OperationBuilder'\nimport BinaryExpressionTreeProvider, {\n  useBinaryExpressionTree,\n} from './BinaryExpressionTreeProvider'\nimport { PostfixEvaluator } from './PostfixEvaluator'\n\nexport interface IArgsChange {\n  old: {\n    name?: string\n    value?: boolean\n  }\n  new: {\n    name: string\n    value: boolean\n  }\n}\n\nexport default function App() {\n  const [args, setArgs] = React.useState<Args>({})\n  const binaryExpressionTree = useBinaryExpressionTree()\n  const [binaryExpressionTreeNodes, setBinaryExpressionTreeNodes] =\n    React.useState(\n      Array.from(\n        binaryExpressionTree.traversalDFS(binaryExpressionTree.getRootId())\n      )\n    )\n  const [\n    binaryExpressionTreeNodesPostOrder,\n    setBinaryExpressionTreeNodesPostOrder,\n  ] = React.useState(\n    Array.from(\n      binaryExpressionTree.traversalPostOrder(binaryExpressionTree.getRootId())\n    )\n  )\n\n  const updateBinaryExpressionTreeNodes = () => {\n    setBinaryExpressionTreeNodes(\n      Array.from(\n        binaryExpressionTree.traversalDFS(binaryExpressionTree.getRootId())\n      )\n    )\n\n    setBinaryExpressionTreeNodesPostOrder(\n      Array.from(\n        binaryExpressionTree.traversalPostOrder(\n          binaryExpressionTree.getRootId()\n        )\n      )\n    )\n  }\n\n  const onArgsChange = (changedArgs: IArgsChange) => {\n    if (!changedArgs.old.name) {\n      // change reflects new arg addition\n      setArgs({\n        ...args,\n        [changedArgs.new.name]: changedArgs.new.value,\n      })\n    } else if (changedArgs.new.name !== changedArgs.old.name) {\n      // change reflects existing arg name change\n      // Use renameObjectKeysInPlace to keep the same insertion order of the keys in the\n      // args object, thus render the the args GUI in the same order every time.\n      setArgs(\n        renameArgsKeysInPlace(args, {\n          [changedArgs.old.name]: changedArgs.new.name,\n        })\n      )\n    } else {\n      // change reflects existing arg value change\n      setArgs({\n        ...args,\n        [changedArgs.old.name.trim()]: changedArgs.new.value,\n      })\n    }\n  }\n\n  return (\n    <BinaryExpressionTreeProvider>\n      <div>\n        <ArgsBuilder args={args} onArgsChange={onArgsChange} />\n        <OperationBuilder\n          args={args}\n          binaryExpressionTreeNodes={binaryExpressionTreeNodes}\n          updateBinaryExpressionTreeNodes={updateBinaryExpressionTreeNodes}\n          binaryExpressionTree={binaryExpressionTree}\n        />\n        <PostfixEvaluator\n          binaryExpressionTreeNodesPostOrder={\n            binaryExpressionTreeNodesPostOrder\n          }\n          args={args}\n        />\n      </div>\n    </BinaryExpressionTreeProvider>\n  )\n}\n","import type { Args } from './ArgsBuilder'\n\ntype MappedObjectNamesType<T> = { [argName in keyof T]: string }\n\nexport function renameArgsKeysInPlace(\n  obj: Args,\n  newKeys: MappedObjectNamesType<Args>\n): Args {\n  const keyValues = Object.keys(obj).map((key) => ({\n    [key in newKeys ? newKeys[key] : key]: obj[key],\n  }))\n\n  return Object.assign({}, ...keyValues)\n}\n","import { render } from 'react-dom'\n\nimport App from './App'\n\nconst rootElement = document.getElementById('root')\nrender(<App />, rootElement)\n"],"sourceRoot":""}